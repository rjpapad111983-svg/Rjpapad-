<!doctype html>
<html lang="hi">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>RJ Papad - Referral Binary Tree</title>
<style>
  body { font-family: Noto Sans, Arial; margin:0; padding:16px; background:#fffbe6; color:#222; }
  .wrap { display:flex; gap:18px; align-items:flex-start; }
  .panel { background:#fff; border:1px solid #eee; padding:12px; border-radius:8px; box-shadow:0 2px 6px rgba(0,0,0,0.06); }
  .left { width:340px; flex-shrink:0; }
  .right { flex:1; min-width:300px; overflow:auto; max-height:80vh; }
  h2 { margin:6px 0 12px; font-size:1.1rem; }
  label { display:block; margin-top:8px; font-size:0.9rem; }
  input, select, button { width:100%; padding:8px; margin-top:6px; box-sizing:border-box; }
  .small { width:auto; display:inline-block; padding:6px 10px; margin-top:6px; }
  .controls { display:flex; gap:8px; margin-top:8px; }
  .node-info { display:flex; gap:8px; align-items:center; padding:6px; border-radius:6px; background:#f8f8f8; margin-bottom:6px; }
  .node-id { font-weight:700; font-size:0.85rem; }
  .msg { margin-top:8px; color: #2a7a2a; }
  /* SVG container */
  #treeSvg { width:100%; height:100%; min-height:500px; background:linear-gradient(#fff,#fff); border-radius:6px; }
  /* Node styling in SVG */
  .node-rect { cursor:pointer; filter: drop-shadow(0 1px 2px rgba(0,0,0,0.12)); }
  .node-text { font-family: Noto Sans, Arial; font-size:12px; pointer-events:none; }
  .avatar { pointer-events:none; }
  .toolbar { display:flex; gap:8px; margin-top:8px; flex-wrap:wrap; }
  .export-area { width:100%; height:140px; margin-top:8px; font-size:12px; font-family:monospace; }
  .legend { font-size:12px; margin-top:8px; color:#444; }
</style>
</head>
<body>
  <h1>RJ Papad — Team Tree (Binary Referral)</h1>
  <div class="wrap">
    <div class="panel left">
      <h2>नया ग्राहक जोड़ें / रजिस्टर</h2>

      <label>नाम</label>
      <input id="inpName" placeholder="नाम लिखें (जैसे: राजेश)" />

      <label>लिंग</label>
      <select id="inpGender">
        <option value="male">Male</option>
        <option value="female">Female</option>
      </select>

      <label>मोबाइल (10 अंक)</label>
      <input id="inpMobile" placeholder="6353745646" />

      <label>Parent चुनें (यदि खाली छोड़ा तो Auto-fill)</label>
      <select id="selParent">
        <option value="">-- कोई नहीं (Auto-fill) --</option>
      </select>

      <div class="controls">
        <select id="selSide" class="small">
          <option value="left">Left</option>
          <option value="right">Right</option>
          <option value="any">Any (auto)</option>
        </select>
        <button id="btnAdd" class="small">Add Customer</button>
      </div>

      <div class="toolbar">
        <button id="btnAddRoot" class="small">Create Root (यदि न हो)</button>
        <button id="btnAutoFill" class="small">Auto-fill 1 node</button>
        <button id="btnClear" class="small">Clear All</button>
      </div>

      <div class="legend">
        <strong>Usage:</strong> Auto-fill भरता है breadth-first (left then right). आप किसी parent चुनकर left/right में भी जोड़ सकते हैं.<br/>
        Node पर क्लिक करके उसकी subtree ऊपर दाईं विंडो में देखिए.
      </div>

      <h2 style="margin-top:12px">Export / Import</h2>
      <button id="btnExport" class="small">Export JSON</button>
      <button id="btnImport" class="small">Import JSON (overwrite)</button>
      <textarea id="exportArea" class="export-area" placeholder="Exported JSON दिखेगा यहाँ"></textarea>
      <p id="status" class="msg"></p>
    </div>

    <div class="panel right">
      <h2>Tree View</h2>
      <div style="display:flex; gap:8px; align-items:center;">
        <label style="margin:0;">देखें (ID/मोबाइल):</label>
        <input id="viewInput" placeholder="customer id या मोबाइल डालें" style="width:220px;" />
        <button id="btnView" class="small">View My Team</button>
        <button id="btnViewAll" class="small">View Full Tree</button>
      </div>

      <svg id="treeSvg" xmlns="http://www.w3.org/2000/svg"></svg>
      <p class="legend">Click node to select it (shows subtree). Zoom/scroll supported by browser.</p>
    </div>
  </div>

<script>
/*
  Simple binary tree manager persisted in localStorage.
  Node structure:
    { id: "n1", name:"Rajesh", gender:"male", mobile:"635...", left: null|id, right: null|id }
  rootId stored separately.
*/

const STORAGE_KEY = 'rjpapad_tree_v1';

// helper: generate short unique id
function uid() {
  return 'n' + Math.random().toString(36).slice(2,9);
}

// load/save
function loadState() {
  try {
    const raw = localStorage.getItem(STORAGE_KEY);
    if (!raw) return { nodes: {}, rootId: null };
    return JSON.parse(raw);
  } catch(e) {
    console.error(e);
    return { nodes: {}, rootId: null };
  }
}
function saveState(state) {
  localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
  updateUI();
}

let state = loadState();

// UI elements
const selParent = document.getElementById('selParent');
const btnAdd = document.getElementById('btnAdd');
const btnAddRoot = document.getElementById('btnAddRoot');
const btnAutoFill = document.getElementById('btnAutoFill');
const btnClear = document.getElementById('btnClear');
const btnExport = document.getElementById('btnExport');
const btnImport = document.getElementById('btnImport');
const exportArea = document.getElementById('exportArea');
const status = document.getElementById('status');
const treeSvg = document.getElementById('treeSvg');
const btnView = document.getElementById('btnView');
const btnViewAll = document.getElementById('btnViewAll');
const viewInput = document.getElementById('viewInput');

document.getElementById('btnAdd').addEventListener('click', () => {
  const name = document.getElementById('inpName').value.trim() || 'Unnamed';
  const gender = document.getElementById('inpGender').value;
  const mobile = document.getElementById('inpMobile').value.trim();
  if (!/^\d{10}$/.test(mobile)) { alert('सही 10-अंकों वाला मोबाइल डालें'); return; }

  const parent = selParent.value || null;
  const side = document.getElementById('selSide').value;
  addCustomer({ name, gender, mobile }, parent, side);
});

btnAddRoot.addEventListener('click', () => {
  if (state.rootId) { alert('Root पहले से मौजूद है: ' + state.rootId); return; }
  const id = uid(); state.rootId = id; state.nodes[id] = { id, name:'ROOT', gender:'male', mobile:'', left:null, right:null };
  saveState(state);
});

btnAutoFill.addEventListener('click', () => {
  // try add sample demo user quickly
  const sample = { name: 'User'+Object.keys(state.nodes).length, gender: Math.random()>0.5?'male':'female', mobile: String(6000000000 + Math.floor(Math.random()*900000000)).slice(0,10) };
  addCustomer(sample, null, 'any');
});

btnClear.addEventListener('click', () => {
  if (!confirm('सभी डेटा हट जाएगा — पुष्टि करें?')) return;
  state = { nodes: {}, rootId: null }; saveState(state); renderTree();
});

btnExport.addEventListener('click', () => {
  exportArea.value = JSON.stringify(state, null, 2);
  status.innerText = 'JSON तैयार है — copy करें या Save करें.';
});

btnImport.addEventListener('click', () => {
  try {
    const parsed = JSON.parse(exportArea.value);
    if (!parsed || typeof parsed !== 'object' || !parsed.nodes) throw new Error('Invalid JSON');
    state = parsed;
    saveState(state);
    status.innerText = 'Import सफल।';
  } catch(e) {
    alert('Import fail: ' + e.message);
  }
});

btnView.addEventListener('click', () => {
  const q = viewInput.value.trim();
  if (!q) { alert('ID या मोबाइल डालें'); return; }
  // try find by id or mobile
  let id = null;
  if (state.nodes[q]) id = q;
  else {
    for (const k in state.nodes) {
      if (state.nodes[k].mobile === q) { id = k; break; }
    }
  }
  if (!id) { alert('Node नहीं मिला'); return; }
  renderTree(id); // render subtree from id (only downwards)
});

btnViewAll.addEventListener('click', () => renderTree());

// Add customer logic
function addCustomer({ name, gender, mobile }, parentId=null, side='any') {
  if (!state.rootId) {
    // create root first automatically if missing
    const r = uid(); state.rootId = r;
    state.nodes[r] = { id: r, name: 'ROOT', gender:'male', mobile:'', left:null, right:null };
  }

  const newId = uid();
  state.nodes[newId] = { id:newId, name, gender, mobile, left:null, right:null };

  if (!parentId) {
    // breadth-first auto-fill: find first node with empty left/right
    const q = [state.rootId];
    let placed = false;
    while (q.length && !placed) {
      const cur = q.shift();
      const node = state.nodes[cur];
      if (!node.left) { node.left = newId; placed = true; break; }
      else q.push(node.left);
      if (!node.right) { node.right = newId; placed = true; break; }
      else q.push(node.right);
    }
    if (!placed) {
      // extremely unlikely; attach to root right
      state.nodes[state.rootId].right = newId;
    }
  } else {
    const parent = state.nodes[parentId];
    if (!parent) { alert('Parent not found'); delete state.nodes[newId]; return; }
    if (side === 'left') {
      if (parent.left) { alert('Left occupied. Choose another parent or side.'); delete state.nodes[newId]; return; }
      parent.left = newId;
    } else if (side === 'right') {
      if (parent.right) { alert('Right occupied. Choose another parent or side.'); delete state.nodes[newId]; return; }
      parent.right = newId;
    } else { // any -> pick left then right
      if (!parent.left) parent.left = newId;
      else if (!parent.right) parent.right = newId;
      else { alert('Parent has both children.'); delete state.nodes[newId]; return; }
    }
  }

  saveState(state);
  document.getElementById('status').innerText = `Added ${name} (${newId}) under ${parentId || 'auto'}`;
}

// UI updater
function updateUI() {
  // update parent select
  selParent.innerHTML = '<option value="">-- कोई नहीं (Auto-fill) --</option>';
  for (const id in state.nodes) {
    const n = state.nodes[id];
    const txt = `${n.name || '(no-name)'} ${n.mobile? '('+n.mobile+')':''} [${id}]`;
    const opt = document.createElement('option'); opt.value = id; opt.innerText = txt;
    selParent.appendChild(opt);
  }
  renderTree(); // refresh
}

// SVG tree layout + render
function renderTree(subRootId) {
  // prepare nodes map copy
  const nodes = state.nodes;
  treeSvg.innerHTML = '';
  if (!state.rootId) {
    // nothing
    const t = document.createElementNS('http://www.w3.org/2000/svg','text');
    t.setAttribute('x',20); t.setAttribute('y',40); t.textContent = 'No tree yet. Add root or customer.';
    treeSvg.appendChild(t);
    return;
  }

  const root = subRootId || state.rootId;

  // Build tree objects
  function build(id) {
    const n = nodes[id];
    if (!n) return null;
    return { id:id, name:n.name, gender:n.gender, mobile:n.mobile, left: n.left? build(n.left) : null, right: n.right? build(n.right) : null, raw: n };
  }
  const tree = build(root);

  // compute positions by a simple recursive algorithm (inorder x spacing)
  let xCounter = 0;
  const levelGapY = 120;
  function assign(node, depth=0) {
    if (!node) return;
    assign(node.left, depth+1);
    node.x = xCounter * 160 + 60; // spacing
    node.y = depth * levelGapY + 50;
    xCounter++;
    assign(node.right, depth+1);
  }
  assign(tree);

  // size svg
  const width = Math.max(800, xCounter * 160 + 120);
  const maxDepth = (function md(n){ if(!n) return 0; return 1 + Math.max(md(n.left), md(n.right)); })(tree);
  const height = Math.max(400, (maxDepth+1) * levelGapY);
  treeSvg.setAttribute('viewBox', `0 0 ${width} ${height}`);
  treeSvg.setAttribute('preserveAspectRatio','xMidYMin meet');

  // draw connectors and nodes (do a traversal)
  function drawNode(node) {
    if (!node) return;
    // draw line to children
    if (node.left) {
      const line = document.createElementNS('http://www.w3.org/2000/svg','line');
      line.setAttribute('x1', node.x + 40);
      line.setAttribute('y1', node.y + 40);
      line.setAttribute('x2', node.left.x + 40);
      line.setAttribute('y2', node.left.y + 10);
      line.setAttribute('stroke','#bbb');
      line.setAttribute('stroke-width','2');
      treeSvg.appendChild(line);
    }
    if (node.right) {
      const line = document.createElementNS('http://www.w3.org/2000/svg','line');
      line.setAttribute('x1', node.x + 40);
      line.setAttribute('y1', node.y + 40);
      line.setAttribute('x2', node.right.x + 40);
      line.setAttribute('y2', node.right.y + 10);
      line.setAttribute('stroke','#bbb');
      line.setAttribute('stroke-width','2');
      treeSvg.appendChild(line);
    }

    // node group
    const g = document.createElementNS('http://www.w3.org/2000/svg','g');
    g.setAttribute('transform', `translate(${node.x},${node.y})`);
    g.style.cursor = 'pointer';

    // rect
    const rect = document.createElementNS('http://www.w3.org/2000/svg','rect');
    rect.setAttribute('width','160');
    rect.setAttribute('height','60');
    rect.setAttribute('rx','10');
    rect.setAttribute('class','node-rect');
    rect.setAttribute('fill','#fff');
    rect.setAttribute('stroke','#e1e1e1');
    rect.setAttribute('stroke-width','1');
    g.appendChild(rect);

    // avatar (small circle with simple hair/shape)
    const avatarGroup = document.createElementNS('http://www.w3.org/2000/svg','g');
    avatarGroup.setAttribute('transform','translate(10,10)');
    // circle
    const c = document.createElementNS('http://www.w3.org/2000/svg','circle');
    c.setAttribute('cx','20'); c.setAttribute('cy','20'); c.setAttribute('r','18');
    c.setAttribute('fill', node.gender === 'female' ? '#ffdede' : '#e6f0ff');
    c.setAttribute('stroke','#cccccc');
    avatarGroup.appendChild(c);
    // simple eyes
    const e1 = document.createElementNS('http://www.w3.org/2000/svg','circle');
    e1.setAttribute('cx','14'); e1.setAttribute('cy','20'); e1.setAttribute('r','2');
    e1.setAttribute('fill','#333');
    const e2 = e1.cloneNode(); e2.setAttribute('cx','26');
    avatarGroup.appendChild(e1); avatarGroup.appendChild(e2);
    // hair or bow simple
    if (node.gender === 'female') {
      const bow = document.createElementNS('http://www.w3.org/2000/svg','rect');
      bow.setAttribute('x','6'); bow.setAttribute('y','6'); bow.setAttribute('width','8'); bow.setAttribute('height','6');
      bow.setAttribute('fill','#ff8fb2'); avatarGroup.appendChild(bow);
    } else {
      const hair = document.createElementNS('http://www.w3.org/2000/svg','path');
      hair.setAttribute('d','M6 18 Q20 4 34 18 Z');
      hair.setAttribute('fill','#6b7cff'); avatarGroup.appendChild(hair);
    }
    g.appendChild(avatarGroup);

    // text: name and id
    const nameT = document.createElementNS('http://www.w3.org/2000/svg','text');
    nameT.setAttribute('x','60'); nameT.setAttribute('y','24'); nameT.setAttribute('class','node-text');
    nameT.textContent = (node.name || 'NoName').slice(0,18);
    g.appendChild(nameT);

    const idT = document.createElementNS('http://www.w3.org/2000/svg','text');
    idT.setAttribute('x','60'); idT.setAttribute('y','42'); idT.setAttribute('class','node-text');
    idT.setAttribute('fill','#666');
    idT.textContent = node.id + (node.raw && node.raw.mobile ? ' • ' + node.raw.mobile : '');
    g.appendChild(idT);

    // click -> set viewInput and re-render subtree
    g.addEventListener('click', (e) => {
      e.stopPropagation();
      viewInput.value = node.id;
      renderTree(node.id);
      // highlight: draw border
      // (simple: create temporary stroke) - here we'll just set a status
      status.innerText = `Selected ${node.id} (${node.name}) — showing its subtree`;
    });

    treeSvg.appendChild(g);

    // recursion
    drawNode(node.left); drawNode(node.right);
  }

  drawNode(tree);
  updateUI(); // update parent select etc.
}

// initial load
updateUI();

// clicking on blank svg resets to full tree
treeSvg.addEventListener('click', () => {
  renderTree();
  status.innerText = 'Full tree view';
});
</script>
</body>
</html>
